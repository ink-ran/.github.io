---
title: 算法基础课
date: 2023-03-27 23:22:34
tags:
---

# 第一讲：基础算法

## 快速排列

### 785.快速排列

1.取一个数k（一般为中间值），分别从头和尾遍历数组，使k左边的数小于等于k，k右边的数大于等于k

2.递归

```c++
#include<iostream>
using namespace std;
int a[100010];
void sort(int l,int r)
{
    if(l>=r) return;
    int k=a[(l+r)/2];
    int i=l,j=r;
    for(int x=0;;x++)
    {
        while(a[i]<k) i++;
        while(a[j]>k) j--;
        if(i>=j) break;
        swap(a[i++],a[j--]);
    }
    sort(l,j);
    sort(j+1,r);
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    sort(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

## 归并排序

### 787.归并排序

1.先递归

2.遍历返回来的两个数组，这两个数组已经排好序了（升序），将这两个数组排序，只需要开一个新数组来存，两两比较，小的存入，往后移一格，再次比较。

```c++
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
void suan(int l,int r)
{
    if(l>=r) return;
    int k=(l+r)/2;
    suan(l,k);
    suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)
    {
        if(a[i]<a[j]) b[sz++]=a[i++];
        else b[sz++]=a[j++];
    }
    while(i<=k) b[sz++]=a[i++];
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    suan(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

### 788.逆序对的数量

1.归并排序

2.在排序过程中，当第二的数组中的j小于第一个数组第i的值时说明存在逆对数，并且第一个数组i到结尾的所有数皆与j组成逆对数。

```c
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
long long suan(int l,int r)
{
    if(l>=r) return 0;
    int k=(l+r)/2;
    long long sum=suan(l,k)+suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)
    {
        if(a[i]<=a[j]) b[sz++]=a[i++];
        else sum+=k-i+1,b[sz++]=a[j++];
    }
    while(i<=k) b[sz++]=a[i++];
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];
    return sum;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    long long sum=suan(0,n-1);
    printf("%lld\n",sum);
}
```

## 二分

### 789.数的范围

两次折半查找，一次找头，一次找尾

```c
#include<iostream>
using namespace std;
int a[1000010];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int s=0;
        scanf("%d\n",&s);
        int l=0,r=n-1;
        while(l<r)
        {
            int k=(l+r)/2;
            if(a[k]<s) l=k+1;
            else r=k;
        }
        if(a[l]!=s) printf("-1 -1\n");
        else
        {
            printf("%d ",l);
            l=0,r=n-1;
            while(l<r)
            {
                int k=(l+r)/2+1;
                if(a[k]>s) r=k-1;
                else l=k;
            }
            printf("%d\n",l);
        }
    }
}
```

###  790.数的三次方根

折半查找

```c
#include<stdio.h>
int main()
{
    double n;
    scanf("%lf\n",&n);
    double l=-100,r=100;
    while(r - l > 1e-8)//1e-8指的是1乘以10的-8次方 0.00000001
    {
        double k=(r+l)/2;
        if(k*k*k<n) l=k;
        else r=k;
    }
    printf("%0.6lf\n",r);
}
```

## 高精度

### 791.高精度加法

```c
#include<iostream>
#include<vector>
using namespace std;
int n,m;
int c[100010];
void add(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=a[i]-'0';
        if(i<m) sum+=b[i]-'0';
        c[i]=sum%10;
        sum/=10;
    }
    if(sum) c[n++]=sum;
    return;
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(n>m) add(a,b);
    else swap(n,m),add(b,a);
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 792.高精度减法

```c
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
int n,m;
int c[100010];
void sub(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum=a[i]-'0'-sum;
        if(i<m) sum-=b[i]-'0';
        c[i]=(sum+10)%10;
        if(sum<0) sum=1;
        else sum=0;
    }
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    int flag=0;
    if(m>n||(m==n&&a.compare(b)<0)) flag=1;
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(flag==1)
    {
        swap(n,m);
        sub(b,a);
        printf("-");
    }
    else sub(a,b);
    for(int i=n-1;i>0;i--) //前面的数为0的话，去掉
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 793.高精度乘法

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
void mul(string a,int b)
{
    int sum=0;
    for(int i=n-1;i>=0;i--)
    {
        sum+=(a[i]-'0')*b;
        c.push_back(sum%10);
        sum/=10;
    }
    if(sum!=0) c.push_back(sum);
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    n=a.size();
    mul(a,b);
    n=c.size();
    for(int i=n-1;i>0;i--)
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 794.高精度除法

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
int sum=0;
void div(string a,int b)
{
    for(int i=0;i<n;i++)
    {
        sum=sum*10+a[i]-'0';
        c.push_back(sum/b);
        sum%=b;
    }
}
int main()
{
    string a;
    int b=0;
    cin>>a>>b;
    n=a.size();
    div(a,b);
    n=c.size();
    int m=0;
    for(int i=0;i<n-1;i++)
        if(c[i]==0) m++;
        else break;
    for(int i=m;i<n;i++) printf("%d",c[i]);
    printf("\n%d",sum);
}
```

## 前缀和

### 795.前缀和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N];
int main()
{
    int n,m;
    cin>>n>>m;
    int x=0;
    for(int i=1;i<=n;i++) cin>>x,a[i]=a[i-1]+x;
    for(int i=0;i<m;i++) 
    {
        int l,r;
        cin>>l>>r;
        printf("%d\n",a[r]-a[l-1]);
    }
}
```

### 764.子矩阵的和

```c
#include<iostream>
using namespace std;
const int N=1010;
int a[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d ",&a[i][j]);
            a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
        }
    }
    for(int i=0;i<q;i++)
    {
        int x1,y1,x2,y2;
        scanf("%d %d %d %d\n",&x1,&y1,&x2,&y2);
        printf("%d\n",a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]);
    }
}
```

## 差分

### 797.差分

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int l,r,c;
        cin>>l>>r>>c;
        b[l-1]+=c;
        b[r]-=c;
    }
    int sum=b[0];
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sum+a[i]);
        sum+=b[i];
    }
}
```

### 798.差分矩阵

```c
#include<iostream>//枚举+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        for(int i=x1;i<=x2;i++)
        {
            b[i][y1-1]+=c;
            b[i][y2]-=c;
        }
    }
    for(int i=1;i<=n;i++)
    {
        int sum=b[i][0];
        for(int j=1;j<=m;j++)
        {
            printf("%d ",a[i][j]+sum);
            sum+=b[i][j];
        }
        printf("\n");
    }
}
```

```c
#include<iostream>//前缀和+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x2+1][y2+1]+=c;
    b[x1][y2+1]-=c;
    b[x2+1][y1]-=c;
    b[x1][y1]+=c;
}
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
            
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            insert(i,j,i,j,a[i][j]);
    
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            printf("%d ",b[i][j]);
        }
        printf("\n");
    }
}
```

## 双指针算法

### 799.最长连续不重复子序列

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N];
int b[N];
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    int j=0;//头指针
    int sum=0;
    for(int i=0;i<n;i++)
    {
        b[a[i]]++;
        while(j<i&&b[a[i]]>1) b[a[j++]]--;
        sum=max(sum,i-j+1);
    }
    printf("%d\n",sum);
    return 0;
}
```

### 800.数组元素的目标和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);//升序排序
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);//升序排序
    int sum=0;
    for(int i=0,j=m-1;i<n;i++)
    {
        while(j>=0&&b[j]+a[i]>x) j--;
        if(j>=0&&b[j]+a[i]==x) printf("%d %d\n",i,j); 
    }
}
```

### 2816.判断子序列

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);
    int j=0;
    int flag=0;
    for(int i=0;i<n;i++)
    {
        while(b[j]!=a[i]&&j<m) j++;
        if(b[j]==a[i]&&j<m) j++;
        else 
        {
            flag=1;
            break;
        }
    }
    if(flag==0) printf("Yes\n");
    else printf("No\n");
}
```

## 位运算

### 801.二进制中1的个数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int s=0;
        scanf("%d ",&s);
        int sum=0;
        for(int j=30;~j;j--)//~j==j>=0
        {
            if(s>>j&1) sum++;
        }
        printf("%d ",sum);
    }
}
```

## 离散化

### 802.区间和

```c

```

## 区间合并

### 803.区间合并

```c
#include<iostream>//也可以直接使用数组，求和就行
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
vector<PII> a;
void merge()
{
    int l=-2e9,r=-2e9;
    vector<PII> res;
    for(auto t:a)
    {
        if(r<t.first)
        {
            if(l!=-2e9) res.push_back({l,r});
            l=t.first,r=t.second;
        }
        else r=max(r,t.second);
    }
    if(l!=-2e9) res.push_back({l,r});
    a=res;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a.push_back({l,r});
    }
    sort(a.begin(),a.end());
    merge();
    printf("%d\n",a.size());
}
//也可以直接使用数组，求和就行，个人觉得这样简单一点
/*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
PII a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a[i].first=l;
        a[i].second=r;
    }
    sort(a,a+n);
    int b=a[0].second;
    int sum=1;
    for(int i=0;i<n;i++)
    {
        if(a[i].first<=b) if(a[i].second>b) b=a[i].second;
        if(a[i].first>b)
        {
            sum++;
            b=a[i].second;
        }
    }
    printf("%d\n",sum);
}
*/
```

# 第二讲：数据结构

## 单链表

### 826.单链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],r[N];
int sz;
void insert(int k,int x)
{
    e[sz]=x;
    r[sz]=r[k];
    r[k]=sz++;
}
int main()
{
    int n;
    scanf("%d\n",&n);
    sz=1;//0为头文件
    for(int i=0;i<n;i++)
    {
        char s;
        scanf("%c ",&s);
        int k,x;
        if(s=='H')
        {
            scanf("%d\n",&x);
            insert(0,x);
        }
        if(s=='D')
        {
            scanf("%d\n",&k);
            r[k]=r[r[k]];
        }
        if(s=='I')
        {
            scanf("%d %d\n",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i]) printf("%d ",e[i]);
}
```



## 双链表

### 827.双链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],l[N],r[N];
int sz;

void insert(int k,int x)//在第k个插入的数右端插入一个数
{
    e[sz]=x;
    l[sz]=k; r[sz]=r[k];
    l[r[k]]=sz; r[k]=sz++; 
}
void remove(int k)//删除节点
{
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    sz=1;//头文件
    for(int i=0;i<n;i++)
    {
        string t;
        cin>>t;
        int k,x;
        if(t=="L")
        {
            scanf("%d ",&x);
            insert(0,x);
        }
        if(t=="R")
        {
            scanf("%d ",&x);
            insert(l[0],x);
        }
        if(t=="D")
        {
            scanf("%d ",&k);
            remove(k);
        }
        if(t=="IL")
        {
            scanf("%d %d",&k,&x);
            insert(l[k],x);
        }
        if(t=="IR")
        {
            scanf("%d %d",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i])
    {
        printf("%d ",e[i]);
    }
}
```

## 哈希表

### 840.模拟哈希表

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=2000003,null=0x3f3f3f3f;//开放寻址法，定N时，要扩大到数据范围的2~3倍
int a[N];
int find(int x)
{
    int k=(x%N+N)%N;
    while(a[k]!=x&&a[k]!=null) k++;//if(k==N) k=0;这题的数据用不上这个，但是其他题不一定。作用：防止数组越界
    return k;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    memset(a,0x3f,sizeof a);//int类型为四个字节，所以会有四个3f
    for(int i=0;i<n;i++)
    {
        char t;
        int x;
        scanf("%c %d\n",&t,&x);
        int s=find(x);
        if(t=='I') a[s]=x;
        else
        {
            if(a[s]==x) printf("Yes\n");
            else printf("No\n");
        }
    }
}
```





# 第三讲：搜索与图论

## 拓扑排序

### 848.有向图的拓扑序列

#### 条件：有向无环图

```c
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100010;
int h[N],e[N],ne[N];
int s=0;
int a[N];
int d[N];
int n,m;
queue<int> q;
int add(int x,int y)//建图
{
    ne[s]=h[x],e[s]=y,h[x]=s++;
}
bool topsort()
{
    int sz=0;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        a[sz++]=t;
        for(int j=h[t];j!=-1;j=ne[j])
        {
            d[e[j]]--;//入度减1
            if(d[e[j]]==0) q.push(e[j]);//入度为0，进入排序
        }
    }
    if(sz==n) return true;
    else return false;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
        d[y]++;
    }
    for(int i=1;i<=n;i++)//入度为0的点
    {
        if(d[i]==0) q.push(i);
    }
    if(topsort())
    {
        for(int i=0;i<n;i++) printf("%d ",a[i]);
    }
    else printf("-1\n");
}
```
