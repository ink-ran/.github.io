---
title: 算法基础课
date: 2023-04-12 13:58:34
tags:
---

# 第一讲：基础算法

## 快速排列

### 785.快速排列

1.取一个数k（一般为中间值），分别从头和尾遍历数组，使k左边的数小于等于k，k右边的数大于等于k

2.递归

时间复杂度：O(nlogn)~O(n^2)(在这题就有很好的说明)

```c++
#include<iostream>
using namespace std;
int a[100010];
void sort(int l,int r)
{
    if(l>=r) return;
    int k=a[(l+r)/2];
    int i=l,j=r;
    for(int x=0;;x++)
    {
        while(a[i]<k) i++;//找到大于中间值的数
        while(a[j]>k) j--;//找到小于中间值的数
        if(i>=j) break;
        swap(a[i++],a[j--]);//存在，互换
    }
    sort(l,j);
    sort(j+1,r);
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    sort(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

## 归并排序

### 787.归并排序

1.先递归

2.遍历返回来的两个数组，这两个数组已经排好序了（升序），将这两个数组排序，只需要开一个新数组来存，两两比较，小的存入，往后移一格，再次比较。

```c++
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
void suan(int l,int r)
{
    if(l>=r) return;
    int k=(l+r)/2;
    suan(l,k);
    suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)//此时的两节数组已排好序，找到两个数组对头相对来说更小的数，加上进b数组，并将该数"删除"
    {
        if(a[i]<a[j]) b[sz++]=a[i++];
        else b[sz++]=a[j++];
    }
    while(i<=k) b[sz++]=a[i++];//若有多余的数，添加到b数组末尾
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];//更新a数组
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    suan(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

### 788.逆序对的数量

1.归并排序

2.在排序过程中，当第二的数组中的j小于第一个数组第i的值时说明存在逆对数，并且第一个数组i到结尾的所有数皆与j组成逆对数。

```c
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
long long suan(int l,int r)
{
    if(l>=r) return 0;
    int k=(l+r)/2;
    long long sum=suan(l,k)+suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)
    {
        if(a[i]<=a[j]) b[sz++]=a[i++];
        else sum+=k-i+1,b[sz++]=a[j++];//当前形成了一组逆对数，根据排列可以得出a[i]~k都满足条件
    }
    while(i<=k) b[sz++]=a[i++];
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];
    return sum;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    long long sum=suan(0,n-1);
    printf("%lld\n",sum);
}
```

## 二分

### 789.数的范围

两次折半查找，一次找头，一次找尾

```c
#include<iostream>
using namespace std;
int a[1000010];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int s=0;
        scanf("%d\n",&s);
        int l=0,r=n-1;
        while(l<r)//第一次出现
        {
            int k=(l+r)/2;
            if(a[k]<s) l=k+1;
            else r=k;
        }
        if(a[l]!=s) printf("-1 -1\n");//不存在的情况
        else//最后一次出现
        {
            printf("%d ",l);
            l=0,r=n-1;
            while(l<r)
            {
                int k=(l+r)/2+1;
                if(a[k]>s) r=k-1;
                else l=k;
            }
            printf("%d\n",l);
        }
    }
}
```

###  790.数的三次方根

折半查找

```c
#include<stdio.h>
int main()
{
    double n;
    scanf("%lf\n",&n);
    double l=-100,r=100;
    while(r - l > 1e-8)//1e-8指的是1乘以10的-8次方 0.00000001
    {
        double k=(r+l)/2;
        if(k*k*k<n) l=k;
        else r=k;
    }
    printf("%0.6lf\n",r);//保留六位小数
}
```

## 高精度

### 791.高精度加法

就简单的加法，没事么要注意的，可能输出要注意一下，还有一开始的位置掉换

```c
#include<iostream>
#include<vector>
using namespace std;
int n,m;
int c[100010];
void add(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=a[i]-'0';
        if(i<m) sum+=b[i]-'0';
        c[i]=sum%10;
        sum/=10;
    }
    if(sum) c[n++]=sum;
    return;
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(n>m) add(a,b);
    else swap(n,m),add(b,a);
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 792.高精度减法

重点在找哪个数更大

```c
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
int n,m;
int c[100010];
void sub(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum=a[i]-'0'-sum;
        if(i<m) sum-=b[i]-'0';
        c[i]=(sum+10)%10;
        if(sum<0) sum=1;//是否需要借位
        else sum=0;
    }
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    int flag=0;
    if(m>n||(m==n&&a.compare(b)<0)) flag=1;
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(flag==1)//进行判断，将大的数传入a，小的传入b
    {
        swap(n,m);//长度也要变
        sub(b,a);
        printf("-");
    }
    else sub(a,b);
    for(int i=n-1;i>0;i--) //前面的数为0的话，去掉
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 793.高精度乘法

和加法差不多

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
void mul(string a,int b)
{
    int sum=0;
    for(int i=n-1;i>=0;i--)
    {
        sum+=(a[i]-'0')*b;
        c.push_back(sum%10);
        sum/=10;
    }
    if(sum!=0) c.push_back(sum);
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    n=a.size();
    mul(a,b);
    n=c.size();
    for(int i=n-1;i>0;i--)
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 794.高精度除法

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
int sum=0;
void div(string a,int b)
{
    for(int i=0;i<n;i++)
    {
        sum=sum*10+a[i]-'0';
        c.push_back(sum/b);
        sum%=b;
    }
}
int main()
{
    string a;
    int b=0;
    cin>>a>>b;
    n=a.size();
    div(a,b);
    n=c.size();
    int m=0;
    for(int i=0;i<n-1;i++)//结果规范化
        if(c[i]==0) m++;
        else break;
    for(int i=m;i<n;i++) printf("%d",c[i]);
    printf("\n%d",sum);
}
```

## 前缀和

### 795.前缀和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N];
int main()
{
    int n,m;
    cin>>n>>m;
    int x=0;
    for(int i=1;i<=n;i++) cin>>x,a[i]=a[i-1]+x;
    for(int i=0;i<m;i++) 
    {
        int l,r;
        cin>>l>>r;
        printf("%d\n",a[r]-a[l-1]);
    }
}
```

### 764.子矩阵的和

如何划分和具体计算是个问题

```c
#include<iostream>
using namespace std;
const int N=1010;
int a[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d ",&a[i][j]);
            a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
        }
    }
    for(int i=0;i<q;i++)
    {
        int x1,y1,x2,y2;
        scanf("%d %d %d %d\n",&x1,&y1,&x2,&y2);
        printf("%d\n",a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]);
    }
}
```

## 差分

### 797.差分

关于这个可以看[树状数组](https://oi-wiki.org/ds/fenwick/)里关于差分的部分，我觉得挺好

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int l,r,c;
        cin>>l>>r>>c;
        b[l-1]+=c;
        b[r]-=c;
    }
    int sum=b[0];
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sum+a[i]);
        sum+=b[i];
    }
}
```

### 798.差分矩阵

```c
#include<iostream>//枚举+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        for(int i=x1;i<=x2;i++)//改变的是每一列的值
        {
            b[i][y1-1]+=c;
            b[i][y2]-=c;
        }
    }
    for(int i=1;i<=n;i++)
    {
        int sum=b[i][0];
        for(int j=1;j<=m;j++)
        {
            printf("%d ",a[i][j]+sum);
            sum+=b[i][j];
        }
        printf("\n");
    }
}
```

```c
#include<iostream>//前缀和+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x2+1][y2+1]+=c;
    b[x1][y2+1]-=c;
    b[x2+1][y1]-=c;
    b[x1][y1]+=c;
}
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
            
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            insert(i,j,i,j,a[i][j]);
    
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);//改变的是前缀和
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            printf("%d ",b[i][j]);
        }
        printf("\n");
    }
}
```

## 双指针算法

我的理解就是找到规律，并恰当剪枝，不进行那么多次的遍历

### 799.最长连续不重复子序列

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N];
int b[N];
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    int j=0;//头指针
    int sum=0;
    for(int i=0;i<n;i++)
    {
        b[a[i]]++;
        while(j<i&&b[a[i]]>1) b[a[j++]]--;//超过两次的话，找到第一次出现的数删除，并在找的同时删除前面出现的数，题目要求连续
        sum=max(sum,i-j+1);
    }
    printf("%d\n",sum);
    return 0;
}
```

### 800.数组元素的目标和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);//升序排序
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);//升序排序
    int sum=0;
    for(int i=0,j=m-1;i<n;i++)
    {
        while(j>=0&&b[j]+a[i]>x) j--;
        if(j>=0&&b[j]+a[i]==x) printf("%d %d\n",i,j); 
    }
}
```

### 2816.判断子序列

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);
    int j=0;
    int flag=0;
    for(int i=0;i<n;i++)
    {
        while(b[j]!=a[i]&&j<m) j++;
        if(b[j]==a[i]&&j<m) j++;
        else 
        {
            flag=1;
            break;
        }
    }
    if(flag==0) printf("Yes\n");
    else printf("No\n");
}
```

## 位运算

### 801.二进制中1的个数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int s=0;
        scanf("%d ",&s);
        int sum=0;
        for(int j=30;~j;j--)//~j==j>=0
        {
            if(s>>j&1) sum++;
        }
        printf("%d ",sum);
    }
}
```

## 离散化

### 802.区间和

```c

```

## 区间合并

### 803.区间合并

```c
#include<iostream>//也可以直接使用数组，求和就行
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
vector<PII> a;
void merge()
{
    int l=-2e9,r=-2e9;
    vector<PII> res;
    for(auto t:a)
    {
        if(r<t.first)
        {
            if(l!=-2e9) res.push_back({l,r});
            l=t.first,r=t.second;
        }
        else r=max(r,t.second);
    }
    if(l!=-2e9) res.push_back({l,r});
    a=res;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a.push_back({l,r});
    }
    sort(a.begin(),a.end());
    merge();
    printf("%d\n",a.size());
}
//也可以直接使用数组，求和就行，个人觉得这样简单一点
/*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
PII a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a[i].first=l;
        a[i].second=r;
    }
    sort(a,a+n);
    int b=a[0].second;
    int sum=1;
    for(int i=0;i<n;i++)
    {
        if(a[i].first<=b) if(a[i].second>b) b=a[i].second;
        if(a[i].first>b)
        {
            sum++;
            b=a[i].second;
        }
    }
    printf("%d\n",sum);
}
*/
```

# 第二讲：数据结构

## 单链表

### 826.单链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],r[N];
int sz;
void insert(int k,int x)
{
    e[sz]=x;
    r[sz]=r[k];
    r[k]=sz++;
}
int main()
{
    int n;
    scanf("%d\n",&n);
    sz=1;//0为头文件
    for(int i=0;i<n;i++)
    {
        char s;
        scanf("%c ",&s);
        int k,x;
        if(s=='H')
        {
            scanf("%d\n",&x);
            insert(0,x);
        }
        if(s=='D')
        {
            scanf("%d\n",&k);
            r[k]=r[r[k]];
        }
        if(s=='I')
        {
            scanf("%d %d\n",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i]) printf("%d ",e[i]);
}
```



## 双链表

### 827.双链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],l[N],r[N];
int sz;

void insert(int k,int x)//在第k个插入的数右端插入一个数
{
    e[sz]=x;
    l[sz]=k; r[sz]=r[k];
    l[r[k]]=sz; r[k]=sz++; 
}
void remove(int k)//删除节点
{
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    sz=1;//头文件
    for(int i=0;i<n;i++)
    {
        string t;
        cin>>t;
        int k,x;
        if(t=="L")
        {
            scanf("%d ",&x);
            insert(0,x);
        }
        if(t=="R")
        {
            scanf("%d ",&x);
            insert(l[0],x);
        }
        if(t=="D")
        {
            scanf("%d ",&k);
            remove(k);
        }
        if(t=="IL")
        {
            scanf("%d %d",&k,&x);
            insert(l[k],x);
        }
        if(t=="IR")
        {
            scanf("%d %d",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i])
    {
        printf("%d ",e[i]);
    }
}
```

## 栈

### 828.模拟栈

```c
#include<iostream>
using namespace std;
int a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int r=0;
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        int x=0;
        if(s=="push") 
        {
            scanf("%d\n",&x);
            a[r++]=x;
        }
        if(s=="pop") r--;
        if(s=="empty") 
            if(r==0) printf("YES\n");
            else printf("NO\n");
        if(s=="query") printf("%d\n",a[r-1]);
    }
}
```

### 3302.表达式求值

```c
#include<iostream>
#include<cstring>
#include<map>
#include<stack>//栈
using namespace std;
stack<int> num;//值
stack<char> op;//运算符
void eval()
{
    int b=num.top();num.pop();//出栈顶元素，并删除
    int a=num.top();num.pop();
    char c=op.top();op.pop();
    int x=0;
    if(c=='+') x=a+b;
    if(c=='-') x=a-b;
    if(c=='*') x=a*b;
    if(c=='/') x=a/b;
    num.push(x);//入栈
}
int main()
{
    map<char,int> m{{'+',1},{'-',1},{'*',2},{'/',2}};//用来判断先乘除后加减
    string s;
    cin>>s;
    for(int i=0;i<s.size();i++)
    {
        if(isdigit(s[i]))//判断s[i]是否为十进制数字符，是返回非0，不是返回0
        {
            int j=i;
            int sum=0;
            while(j<s.size()&&isdigit(s[j])) sum=sum*10+s[j++]-'0';
            i=j-1;
            num.push(sum);
        }
        else if(s[i]=='(') op.push(s[i]);
        else if(s[i]==')') 
        {
            while(op.top()!='(') eval();//先算括号内的
            op.pop();//将(删除
        }
        else 
        {
            while(op.size()&&op.top()!='('&&m[s[i]]<=m[op.top()]) eval();//如果当前是+，而op的栈顶是*，就先进行*，再+，简单来说就是先乘除后加减
            op.push(s[i]);
        }
    }
    while(op.size()) eval();
    printf("%d\n",num.top());
}
```



## 队列

### 829.模拟队列

```c
#include<iostream>
using namespace std;
int a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int l=0,r=0;
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        int x=0;
        if(s=="push")
        {
            scanf("%d\n",&x);
            a[r++]=x;
        }
        if(s=="pop") l++;
        if(s=="empty")
        {
            if(l==r) printf("YES\n");
            else printf("NO\n");
        }
        if(s=="query") printf("%d\n",a[l]);
    }
}
```

## 单调栈

### 830.单调栈

```c
#include<iostream>
#include<stack>
using namespace std;
stack<int> z;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int a=0;
        scanf("%d ",&a);
        while(z.size()&&z.top()>=a) z.pop();
        if(z.empty()) printf("-1 ");
        else printf("%d ",z.top());
        z.push(a);
    }
}
```

## 单调队列

### 滑动窗口

```c
#include<iostream>
using namespace std;
const int N=1000010;
int a[N],b[N];
int main()
{
    int n=0,k=0;
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    int l=0,r=0;
    for(int i=0;i<n;i++)
    {
        if(i-k+1>b[l]) l++;
        while(l<r&&a[b[r-1]]>a[i]) r--;
        b[r++]=i;
        if(i>=k-1) printf("%d ",a[b[l]]);
    }
    printf("\n");
    l=0,r=0;
    for(int i=0;i<n;i++)
    {
        if(i-k+1>b[l]) l++;
        while(l<r&&a[b[r-1]]<a[i]) r--;
        b[r++]=i;
        if(i>=k-1) printf("%d ",a[b[l]]);
    }
}
```

## KMP

### KMP字符串

```c
#include<iostream>
using namespace std;
int a[100010];
char b[100010],c[1000010];
int main()
{
    int n,m;
    scanf("%d %s %d %s\n",&n,b+1,&m,c+1);
    int sz=0;
    for(int i=2;i<=n;i++)//确定b内的KMP
    {
        while(sz&&b[i]!=b[sz+1]) sz=a[sz];
        if(b[i]==b[sz+1]) sz++;
        a[i]=sz;
    }
    sz=0;
    for(int i=1;i<=m;i++)//xun'zhao
    {
        while(sz&&b[sz+1]!=c[i]) sz=a[sz];
        if(b[sz+1]==c[i]) sz++;
        if(sz==n)
        {
            printf("%d ",i-n);
            sz=a[sz];
        }
    }
}
```

## Trie

功能：高效的存储和查找字符串集合

Trie对应的是一棵树，建立树是这个算法的重点

### 835.Trie字符串统计

```c
#include<iostream>
#include<cstring>
using namespace std;
const int N=100010;
int a[N][26],d[N],sum;//a[N]表示该某个节点的下一层节点的的位置(注意：并不是表示同一个根节点下的一层完整节点，只包含一部分)，a[][26]表示这个节点的下一层只包含26个字母
//d表示当前节点为该字符串末尾的次数
string s;
void insert()
{
    int p=0;
    for(int i=0;i<s.size();i++)
    {
        int u=s[i]-'a';
        if(!a[p][u]) a[p][u]=++sum;//下一层不存在，建立
        p=a[p][u];//存在，往下
    }
    d[p]++;//当前节点为该字符串末尾的次数加一，此处的代表的是这个节点在有下一层的情况下，对应的下标
}
int query()
{
    int p=0;
    for(int i=0;i<s.size();i++)
    {
        int u=s[i]-'a';
        if(!a[p][u]) return 0;
        p=a[p][u];
    }
    return d[p];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        char t[2];
        scanf("%s",t);
        cin>>s;
        if(t[0]=='I') insert();
        else printf("%d\n",query());
    }
}
```



## 并查集

### 836.合并集合

```c
#include<iostream>
using namespace std;
int a[100010];
int find(int x)
{
    if(a[x]!=x) a[x]=find(a[x]);
    return a[x];
}
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++) a[i]=i;
    for(int i=1;i<=m;i++)
    {
        char s;
        int x,y;
        scanf("%c %d %d\n",&s,&x,&y);
        x=find(x);
        y=find(y);
        if(s=='M') a[x]=y;
        else 
        {
            if(x==y) printf("Yes\n");
            else printf("No\n");
        }
    }
}
```

### 837.连通块中点d

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],d[N];
int find(int x)
{
    if(a[x]!=x) a[x]=find(a[x]);
    return a[x];
}
int main()
{
    int n=0,m=0;
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&a[i]);
        a[i]=i;
        d[i]=1;
    }
    for(int i=0;i<m;i++)
    {
        string s;
        cin>>s;
        int x=0,y=0;
        scanf("%d\n",&x);
        if(s=="C")
        {
            scanf("%d\n",&y);
            x=find(x);
            y=find(y);
            a[x]=y;
            if(x!=y) d[y]+=d[x];//防止相同累加
        }
        if(s=="Q1") 
        {
            scanf("%d\n",&y);
            x=find(x);
            y=find(y);
            if(x==y) printf("Yes\n");
            else printf("No\n");
        }
        if(s=="Q2")
        {
            x=find(x);
            printf("%d\n",d[x]);
        }
    }
}
```



## 哈希表

### 840.模拟哈希表

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=2000003,null=0x3f3f3f3f;//开放寻址法，定N时，要扩大到数据范围的2~3倍
int a[N];
int find(int x)
{
    int k=(x%N+N)%N;
    while(a[k]!=x&&a[k]!=null) k++;//if(k==N) k=0;这题的数据用不上这个，但是其他题不一定。作用：防止数组越界
    return k;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    memset(a,0x3f,sizeof a);//int类型为四个字节，所以会有四个3f
    for(int i=0;i<n;i++)
    {
        char t;
        int x;
        scanf("%c %d\n",&t,&x);
        int s=find(x);
        if(t=='I') a[s]=x;
        else
        {
            if(a[s]==x) printf("Yes\n");
            else printf("No\n");
        }
    }
}
```

# 第三讲：搜索与图论

## 拓扑排序

### 848.有向图的拓扑序列

#### 条件：有向无环图

```c
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100010;
int h[N],e[N],ne[N];
int s=0;
int a[N];
int d[N];
int n,m;
queue<int> q;
int add(int x,int y)//建图
{
    ne[s]=h[x],e[s]=y,h[x]=s++;
}
bool topsort()
{
    int sz=0;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        a[sz++]=t;
        for(int j=h[t];j!=-1;j=ne[j])
        {
            d[e[j]]--;//入度减1
            if(d[e[j]]==0) q.push(e[j]);//入度为0，进入排序
        }
    }
    if(sz==n) return true;
    else return false;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
        d[y]++;
    }
    for(int i=1;i<=n;i++)//入度为0的点
    {
        if(d[i]==0) q.push(i);
    }
    if(topsort())
    {
        for(int i=0;i<n;i++) printf("%d ",a[i]);
    }
    else printf("-1\n");
}
```
