---
title: 算法基础课
date: 2023-04-12 13:58:34
tags:
---

# 第一讲：基础算法

## 快速排列

### 785.快速排列

1.取一个数k（一般为中间值），分别从头和尾遍历数组，使k左边的数小于等于k，k右边的数大于等于k

2.递归

时间复杂度：O(nlogn)~O(n^2)(在这题就有很好的说明)

```c++
#include<iostream>
using namespace std;
int a[100010];
void sort(int l,int r)
{
    if(l>=r) return;
    int k=a[(l+r)/2];
    int i=l,j=r;
    for(int x=0;;x++)
    {
        while(a[i]<k) i++;//找到大于中间值的数
        while(a[j]>k) j--;//找到小于中间值的数
        if(i>=j) break;
        swap(a[i++],a[j--]);//存在，互换
    }
    sort(l,j);
    sort(j+1,r);
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    sort(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

## 归并排序

### 787.归并排序

1.先递归

2.遍历返回来的两个数组，这两个数组已经排好序了（升序），将这两个数组排序，只需要开一个新数组来存，两两比较，小的存入，往后移一格，再次比较。

```c++
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
void suan(int l,int r)
{
    if(l>=r) return;
    int k=(l+r)/2;
    suan(l,k);
    suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)//此时的两节数组已排好序，找到两个数组对头相对来说更小的数，加上进b数组，并将该数"删除"
    {
        if(a[i]<a[j]) b[sz++]=a[i++];
        else b[sz++]=a[j++];
    }
    while(i<=k) b[sz++]=a[i++];//若有多余的数，添加到b数组末尾
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];//更新a数组
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    suan(0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}
```

### 788.逆序对的数量

1.归并排序

2.在排序过程中，当第二的数组中的j小于第一个数组第i的值时说明存在逆对数，并且第一个数组i到结尾的所有数皆与j组成逆对数。

```c
#include<iostream>
using namespace std;
int a[100010];
int b[100010];
long long suan(int l,int r)
{
    if(l>=r) return 0;
    int k=(l+r)/2;
    long long sum=suan(l,k)+suan(k+1,r);
    int i=l,j=k+1,sz=l;
    while(i<=k&&j<=r)
    {
        if(a[i]<=a[j]) b[sz++]=a[i++];
        else sum+=k-i+1,b[sz++]=a[j++];//当前形成了一组逆对数，根据排列可以得出a[i]~k都满足条件
    }
    while(i<=k) b[sz++]=a[i++];
    while(j<=r) b[sz++]=a[j++];
    for(i=l;i<=r;i++) a[i]=b[i];
    return sum;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    long long sum=suan(0,n-1);
    printf("%lld\n",sum);
}
```

## 二分

### 789.数的范围

两次折半查找，一次找头，一次找尾

```c
#include<iostream>
using namespace std;
int a[1000010];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int s=0;
        scanf("%d\n",&s);
        int l=0,r=n-1;
        while(l<r)//第一次出现
        {
            int k=(l+r)/2;
            if(a[k]<s) l=k+1;
            else r=k;
        }
        if(a[l]!=s) printf("-1 -1\n");//不存在的情况
        else//最后一次出现
        {
            printf("%d ",l);
            l=0,r=n-1;
            while(l<r)
            {
                int k=(l+r)/2+1;
                if(a[k]>s) r=k-1;
                else l=k;
            }
            printf("%d\n",l);
        }
    }
}
```

###  790.数的三次方根

折半查找

```c
#include<stdio.h>
int main()
{
    double n;
    scanf("%lf\n",&n);
    double l=-100,r=100;
    while(r - l > 1e-8)//1e-8指的是1乘以10的-8次方 0.00000001
    {
        double k=(r+l)/2;
        if(k*k*k<n) l=k;
        else r=k;
    }
    printf("%0.6lf\n",r);//保留六位小数
}
```

## 高精度

### 791.高精度加法

就简单的加法，没事么要注意的，可能输出要注意一下，还有一开始的位置掉换

```c
#include<iostream>
#include<vector>
using namespace std;
int n,m;
int c[100010];
void add(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=a[i]-'0';
        if(i<m) sum+=b[i]-'0';
        c[i]=sum%10;
        sum/=10;
    }
    if(sum) c[n++]=sum;
    return;
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(n>m) add(a,b);
    else swap(n,m),add(b,a);
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 792.高精度减法

重点在找哪个数更大

```c
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
int n,m;
int c[100010];
void sub(string a,string b)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum=a[i]-'0'-sum;
        if(i<m) sum-=b[i]-'0';
        c[i]=(sum+10)%10;
        if(sum<0) sum=1;//是否需要借位
        else sum=0;
    }
}
int main()
{
    string a,b;
    cin>>a>>b;
    n=a.size(),m=b.size();
    int flag=0;
    if(m>n||(m==n&&a.compare(b)<0)) flag=1;
    for(int i=0;i<n/2;i++) swap(a[i],a[n-i-1]);
    for(int i=0;i<m/2;i++) swap(b[i],b[m-i-1]);
    if(flag==1)//进行判断，将大的数传入a，小的传入b
    {
        swap(n,m);//长度也要变
        sub(b,a);
        printf("-");
    }
    else sub(a,b);
    for(int i=n-1;i>0;i--) //前面的数为0的话，去掉
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 793.高精度乘法

和加法差不多

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
void mul(string a,int b)
{
    int sum=0;
    for(int i=n-1;i>=0;i--)
    {
        sum+=(a[i]-'0')*b;
        c.push_back(sum%10);
        sum/=10;
    }
    if(sum!=0) c.push_back(sum);
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    n=a.size();
    mul(a,b);
    n=c.size();
    for(int i=n-1;i>0;i--)
        if(c[i]==0) n--;
        else break;
    for(int i=n-1;i>=0;i--) printf("%d",c[i]);
}
```

### 794.高精度除法

```c
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n;
vector<int> c;
int sum=0;
void div(string a,int b)
{
    for(int i=0;i<n;i++)
    {
        sum=sum*10+a[i]-'0';
        c.push_back(sum/b);
        sum%=b;
    }
}
int main()
{
    string a;
    int b=0;
    cin>>a>>b;
    n=a.size();
    div(a,b);
    n=c.size();
    int m=0;
    for(int i=0;i<n-1;i++)//结果规范化
        if(c[i]==0) m++;
        else break;
    for(int i=m;i<n;i++) printf("%d",c[i]);
    printf("\n%d",sum);
}
```

## 前缀和

### 795.前缀和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N];
int main()
{
    int n,m;
    cin>>n>>m;
    int x=0;
    for(int i=1;i<=n;i++) cin>>x,a[i]=a[i-1]+x;
    for(int i=0;i<m;i++) 
    {
        int l,r;
        cin>>l>>r;
        printf("%d\n",a[r]-a[l-1]);
    }
}
```

### 764.子矩阵的和

如何划分和具体计算是个问题

```c
#include<iostream>
using namespace std;
const int N=1010;
int a[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d ",&a[i][j]);
            a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
        }
    }
    for(int i=0;i<q;i++)
    {
        int x1,y1,x2,y2;
        scanf("%d %d %d %d\n",&x1,&y1,&x2,&y2);
        printf("%d\n",a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]);
    }
}
```

## 差分

### 797.差分

关于这个可以看[树状数组](https://oi-wiki.org/ds/fenwick/)里关于差分的部分，我觉得挺好

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++)
    {
        int l,r,c;
        cin>>l>>r>>c;
        b[l-1]+=c;
        b[r]-=c;
    }
    int sum=b[0];
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sum+a[i]);
        sum+=b[i];
    }
}
```

### 798.差分矩阵

```c
#include<iostream>//枚举+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        for(int i=x1;i<=x2;i++)//改变的是每一列的值
        {
            b[i][y1-1]+=c;
            b[i][y2]-=c;
        }
    }
    for(int i=1;i<=n;i++)
    {
        int sum=b[i][0];
        for(int j=1;j<=m;j++)
        {
            printf("%d ",a[i][j]+sum);
            sum+=b[i][j];
        }
        printf("\n");
    }
}
```

```c
#include<iostream>//前缀和+差分
using namespace std;
const int N=1010;
int a[N][N],b[N][N];
void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x2+1][y2+1]+=c;
    b[x1][y2+1]-=c;
    b[x2+1][y1]-=c;
    b[x1][y1]+=c;
}
int main()
{
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d\n",&a[i][j]);
            
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            insert(i,j,i,j,a[i][j]);
    
    for(int x=0;x<q;x++)
    {
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);//改变的是前缀和
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            printf("%d ",b[i][j]);
        }
        printf("\n");
    }
}
```

## 双指针算法

我的理解就是找到规律，并恰当剪枝，不进行那么多次的遍历

### 799.最长连续不重复子序列

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N];
int b[N];
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    int j=0;//头指针
    int sum=0;
    for(int i=0;i<n;i++)
    {
        b[a[i]]++;
        while(j<i&&b[a[i]]>1) b[a[j++]]--;//超过两次的话，找到第一次出现的数删除，并在找的同时删除前面出现的数，题目要求连续
        sum=max(sum,i-j+1);
    }
    printf("%d\n",sum);
    return 0;
}
```

### 800.数组元素的目标和

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);//升序排序
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);//升序排序
    int sum=0;
    for(int i=0,j=m-1;i<n;i++)
    {
        while(j>=0&&b[j]+a[i]>x) j--;
        if(j>=0&&b[j]+a[i]==x) printf("%d %d\n",i,j); 
    }
}
```

### 2816.判断子序列

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],b[N];
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    for(int i=0;i<m;i++) scanf("%d ",&b[i]);
    int j=0;
    int flag=0;
    for(int i=0;i<n;i++)
    {
        while(b[j]!=a[i]&&j<m) j++;
        if(b[j]==a[i]&&j<m) j++;
        else 
        {
            flag=1;
            break;
        }
    }
    if(flag==0) printf("Yes\n");
    else printf("No\n");
}
```

## 位运算

### 801.二进制中1的个数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int s=0;
        scanf("%d ",&s);
        int sum=0;
        for(int j=30;~j;j--)//~j==j>=0
        {
            if(s>>j&1) sum++;
        }
        printf("%d ",sum);
    }
}
```

## 离散化

### 802.区间和

```c

```

## 区间合并

### 803.区间合并

```c
#include<iostream>//也可以直接使用数组，求和就行
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
vector<PII> a;
void merge()
{
    int l=-2e9,r=-2e9;
    vector<PII> res;
    for(auto t:a)
    {
        if(r<t.first)
        {
            if(l!=-2e9) res.push_back({l,r});
            l=t.first,r=t.second;
        }
        else r=max(r,t.second);
    }
    if(l!=-2e9) res.push_back({l,r});//最后一个区间
    a=res;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a.push_back({l,r});
    }
    sort(a.begin(),a.end());
    merge();
    printf("%d\n",a.size());
}
//也可以直接使用数组，求和就行，个人觉得这样简单一点
/*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
PII a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int l,r;
        scanf("%d %d\n",&l,&r);
        a[i].first=l;
        a[i].second=r;
    }
    sort(a,a+n);
    int b=a[0].second;
    int sum=1;
    for(int i=0;i<n;i++)
    {
        if(a[i].first<=b) if(a[i].second>b) b=a[i].second;
        if(a[i].first>b)
        {
            sum++;
            b=a[i].second;
        }
    }
    printf("%d\n",sum);
}
*/
```

# 第二讲：数据结构

## 单链表

### 826.单链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],r[N];
int sz;
void insert(int k,int x)//添加
{
    e[sz]=x;
    r[sz]=r[k];
    r[k]=sz++;
}
int main()
{
    int n;
    scanf("%d\n",&n);
    sz=1;//0为头文件
    for(int i=0;i<n;i++)
    {
        char s;
        scanf("%c ",&s);
        int k,x;
        if(s=='H')
        {
            scanf("%d\n",&x);
            insert(0,x);
        }
        if(s=='D')
        {
            scanf("%d\n",&k);
            r[k]=r[r[k]];
        }
        if(s=='I')
        {
            scanf("%d %d\n",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i]) printf("%d ",e[i]);
}
```



## 双链表

### 827.双链表

```c
#include<iostream>
using namespace std;
const int N=100010;
int e[N],l[N],r[N];
int sz;

void insert(int k,int x)//在第k个插入的数右端插入一个数
{
    e[sz]=x;
    l[sz]=k; r[sz]=r[k];
    l[r[k]]=sz; r[k]=sz++; 
}
void remove(int k)//删除节点
{
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    sz=1;//头文件
    for(int i=0;i<n;i++)
    {
        string t;
        cin>>t;
        int k,x;
        if(t=="L")
        {
            scanf("%d ",&x);
            insert(0,x);
        }
        if(t=="R")
        {
            scanf("%d ",&x);
            insert(l[0],x);
        }
        if(t=="D")
        {
            scanf("%d ",&k);
            remove(k);
        }
        if(t=="IL")
        {
            scanf("%d %d",&k,&x);
            insert(l[k],x);
        }
        if(t=="IR")
        {
            scanf("%d %d",&k,&x);
            insert(k,x);
        }
    }
    for(int i=r[0];i!=0;i=r[i])
    {
        printf("%d ",e[i]);
    }
}
```

## 栈

### 828.模拟栈

```c
#include<iostream>
using namespace std;
int a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int r=0;
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        int x=0;
        if(s=="push") 
        {
            scanf("%d\n",&x);
            a[r++]=x;
        }
        if(s=="pop") r--;
        if(s=="empty") 
            if(r==0) printf("YES\n");
            else printf("NO\n");
        if(s=="query") printf("%d\n",a[r-1]);
    }
}
```

### 3302.表达式求值

```c
#include<iostream>
#include<cstring>
#include<map>
#include<stack>//栈
using namespace std;
stack<int> num;//值
stack<char> op;//运算符
void eval()
{
    int b=num.top();num.pop();//出栈顶元素，并删除
    int a=num.top();num.pop();
    char c=op.top();op.pop();
    int x=0;
    if(c=='+') x=a+b;
    if(c=='-') x=a-b;
    if(c=='*') x=a*b;
    if(c=='/') x=a/b;
    num.push(x);//入栈
}
int main()
{
    map<char,int> m{{'+',1},{'-',1},{'*',2},{'/',2}};//用来判断先乘除后加减
    string s;
    cin>>s;
    for(int i=0;i<s.size();i++)
    {
        if(isdigit(s[i]))//判断s[i]是否为十进制数字符，是返回非0，不是返回0
        {
            int j=i;
            int sum=0;
            while(j<s.size()&&isdigit(s[j])) sum=sum*10+s[j++]-'0';
            i=j-1;
            num.push(sum);
        }
        else if(s[i]=='(') op.push(s[i]);
        else if(s[i]==')') 
        {
            while(op.top()!='(') eval();//先算括号内的
            op.pop();//将(删除
        }
        else 
        {
            while(op.size()&&op.top()!='('&&m[s[i]]<=m[op.top()]) eval();//如果当前是+，而op的栈顶是*，就先进行*，再+，简单来说就是先乘除后加减
            op.push(s[i]);
        }
    }
    while(op.size()) eval();
    printf("%d\n",num.top());
}
```



## 队列

### 829.模拟队列

```c
#include<iostream>
using namespace std;
int a[100010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int l=0,r=0;
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        int x=0;
        if(s=="push")
        {
            scanf("%d\n",&x);
            a[r++]=x;
        }
        if(s=="pop") l++;
        if(s=="empty")
        {
            if(l==r) printf("YES\n");
            else printf("NO\n");
        }
        if(s=="query") printf("%d\n",a[l]);
    }
}
```

## 单调栈

### 830.单调栈

```c
#include<iostream>
#include<stack>
using namespace std;
stack<int> z;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int a=0;
        scanf("%d ",&a);
        while(z.size()&&z.top()>=a) z.pop();
        if(z.empty()) printf("-1 ");
        else printf("%d ",z.top());
        z.push(a);
    }
}
```

## 单调队列

### 滑动窗口

```c
#include<iostream>
using namespace std;
const int N=1000010;
int a[N],b[N];
int main()
{
    int n=0,k=0;
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    int l=0,r=0;
    for(int i=0;i<n;i++)
    {
        if(i-k+1>b[l]) l++;
        while(l<r&&a[b[r-1]]>a[i]) r--;
        b[r++]=i;
        if(i>=k-1) printf("%d ",a[b[l]]);
    }
    printf("\n");
    l=0,r=0;
    for(int i=0;i<n;i++)
    {
        if(i-k+1>b[l]) l++;
        while(l<r&&a[b[r-1]]<a[i]) r--;
        b[r++]=i;
        if(i>=k-1) printf("%d ",a[b[l]]);
    }
}
```

## [KMP](https://oi-wiki.org/string/kmp/)(有点难理解)

### KMP字符串

```c
#include<iostream>
using namespace std;
int a[100010];
char b[100010],c[1000010];
int main()
{
    int n,m;
    scanf("%d %s %d %s\n",&n,b+1,&m,c+1);
    int sz=0;
    for(int i=2;i<=n;i++)//确定b内的KMP
    {
        while(sz&&b[i]!=b[sz+1]) sz=a[sz];
        if(b[i]==b[sz+1]) sz++;
        a[i]=sz;
    }
    sz=0;
    for(int i=1;i<=m;i++)//xun'zhao
    {
        while(sz&&b[sz+1]!=c[i]) sz=a[sz];
        if(b[sz+1]==c[i]) sz++;
        if(sz==n)
        {
            printf("%d ",i-n);
            sz=a[sz];
        }
    }
}
```

## Trie

功能：高效的存储和查找字符串集合

Trie对应的是一棵树，建立树是这个算法的重点

### 835.Trie字符串统计

```c
#include<iostream>
#include<cstring>
using namespace std;
const int N=100010;
int a[N][26],d[N],sum;//a[N]表示该某个节点的下一层节点的的位置(注意：并不是表示同一个根节点下的一层完整节点，只包含一部分)，a[][26]表示这个节点的下一层只包含26个字母
//d表示当前节点为该字符串末尾的次数
string s;
void insert()
{
    int p=0;
    for(int i=0;i<s.size();i++)
    {
        int u=s[i]-'a';
        if(!a[p][u]) a[p][u]=++sum;//下一层不存在，建立
        p=a[p][u];//存在，往下
    }
    d[p]++;//当前节点为该字符串末尾的次数加一，此处的代表的是这个节点在有下一层的情况下，对应的下标
}
int query()
{
    int p=0;
    for(int i=0;i<s.size();i++)
    {
        int u=s[i]-'a';
        if(!a[p][u]) return 0;
        p=a[p][u];
    }
    return d[p];
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        char t[2];
        scanf("%s",t);
        cin>>s;
        if(t[0]=='I') insert();
        else printf("%d\n",query());
    }
}
```

### 143.最大异或树

建树，查找是否存在与之相反的位数存在，异或得1

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=3100010,M=100010;
int a[N][2],sz;
int b[M];
void insert(int x)//建树
{
    int p=0;
    for(int i=30;~i;i--)
    {
        int u=x>>i&1;
        if(!a[p][u]) a[p][u]=++sz;
        p=a[p][u];
    }
}
int query(int x)//查找
{
    int p=0;
    int sum=0;
    for(int i=30;~i;i--)
    {
        int u=x>>i&1;
        if(a[p][1-u]) //存在
        {
            sum+=1<<i;//二进制转十进制
            p=a[p][1-u];//进入与之相反的树节点
        }
        else p=a[p][u];//这里不需要改变sum是因为0*(2^i)=0
    }
    return sum;//返回当前x异或可得到的最大值
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d ",&b[i]);
        insert(b[i]);
    }
    int m=0;
    for(int i=0;i<n;i++) m=max(m,query(b[i]));
    printf("%d\n",m);
}
```



## 并查集

### 836.合并集合

```c
#include<iostream>
using namespace std;
int a[100010];
int find(int x)
{
    if(a[x]!=x) a[x]=find(a[x]);
    return a[x];
}
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++) a[i]=i;
    for(int i=1;i<=m;i++)
    {
        char s;
        int x,y;
        scanf("%c %d %d\n",&s,&x,&y);
        x=find(x);
        y=find(y);
        if(s=='M') a[x]=y;
        else 
        {
            if(x==y) printf("Yes\n");
            else printf("No\n");
        }
    }
}
```

### 837.连通块中点d

```c
#include<iostream>
using namespace std;
const int N=100010;
int a[N],d[N];
int find(int x)
{
    if(a[x]!=x) a[x]=find(a[x]);
    return a[x];
}
int main()
{
    int n=0,m=0;
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&a[i]);
        a[i]=i;
        d[i]=1;
    }
    for(int i=0;i<m;i++)
    {
        string s;
        cin>>s;
        int x=0,y=0;
        scanf("%d\n",&x);
        if(s=="C")
        {
            scanf("%d\n",&y);
            x=find(x);
            y=find(y);
            a[x]=y;
            if(x!=y) d[y]+=d[x];//防止相同累加
        }
        if(s=="Q1") 
        {
            scanf("%d\n",&y);
            x=find(x);
            y=find(y);
            if(x==y) printf("Yes\n");
            else printf("No\n");
        }
        if(s=="Q2")
        {
            x=find(x);
            printf("%d\n",d[x]);
        }
    }
}
```

### 240.食物链



```c
#include<iostream>
using namespace std;
const int N=50010;
int a[N],d[N];//d数组表示的是i到其父节点的距离(父节点并不一定是根节点)
int find(int x)
{
    if(a[x]!=x)
    {
        int t=find(a[x]);
        d[x]+=d[a[x]];
        a[x]=t;
    }
    return a[x];
}
int main()
{
    int n,k;
    scanf("%d %d\n",&n,&k);
    for(int i=1;i<=n;i++) a[i]=i;
    int sum=0;
    for(int i=0;i<k;i++)
    {
        int t,x,y;
        scanf("%d %d %d\n",&t,&x,&y);
        if(x>n||y>n) sum++;
        else 
        {   
            int dx=find(x),dy=find(y);
            if(t==1)
            {
                if(dx==dy&&(d[x]-d[y])%3) sum++;
                else if(dx!=dy)
                {
                    a[dx]=dy;
                    d[dx]=d[y]-d[x];
                }
            }
            else
            {
                if(dx==dy&&(d[x]-d[y]-1)%3) sum++;
                else if(dx!=dy)
                {
                    a[dx]=dy;
                    d[dx]=d[y]+1-d[x];
                }
            }
        }
    }
    printf("%d\n",sum);
}

```

## 堆

### 838.堆排序

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int n,m;
int a[N];
int down(int x)
{
    int s=x;
    if(x*2<=n&&a[x*2]<a[s]) s=x*2;  //找到x节点下的两个节点并比较，找到这三个数中最小的，将位置换成x(父节点)
    if(x*2+1<=n&&a[x*2+1]<a[s]) s=x*2+1;
    if(s!=x)
    {
        swap(a[s],a[x]);
        down(s);//若改变了s节点的值，就还需要判断s的值是否满足小根堆的条件
    }
}
int main()
{
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d ",&a[i]);
    for(int i=n/2;i;i--) down(i);//建立小根堆
    for(int i=0;i<m;i++)
    {
        printf("%d ",a[1]);
        a[1]=a[n--];//将末尾的值换到1的位置
        down(1);//重新排序堆
    }
}
```

### 839.模拟堆

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N],as[N],sz[N],cnt;//as：当前第k个添加的数在a中的位置，sz：当前这个位置对应的k值
void heap_swap(int x,int y)//交换
{
    swap(as[sz[x]],as[sz[y]]);
    swap(sz[x],sz[y]);
    swap(a[x],a[y]);
}
void down(int x)//向下查找
{
    int s=x;
    if(x*2<=cnt&&a[x*2]<a[s]) s=x*2;
    if(x*2+1<=cnt&&a[x*2+1]<a[s]) s=x*2+1;
    if(s!=x)
    {
        heap_swap(s,x);
        down(s);
    }
}
void up(int x)//向上查找
{
    if(x/2>0&&a[x/2]>a[x])
    {
        heap_swap(x,x/2);
        up(x/2);
    }
}
int main()
{
    int n=0,m=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        string s;
        cin>>s;
        int k,x;
        if(s=="I")
        {
            scanf("%d\n",&x);
            as[++m]=++cnt;
            sz[cnt]=m;
            a[cnt]=x;
            up(cnt);
        }
        if(s=="PM") printf("%d\n",a[1]);
        if(s=="DM")
        {
            heap_swap(1,cnt--);
            down(1);
        }
        if(s=="D")
        {
            scanf("%d\n",&k);
            k=as[k];//要记录下来，不然交换完的as[k]fa'sh
            heap_swap(k,cnt--);//在这里已经进行了a[k]与a[cnt]的交换
            up(k);
            down(k);
            
        }
        if(s=="C")
        {
            scanf("%d %d\n",&k,&x);
            a[as[k]]=x;
            down(as[k]);
            up(as[k]);
        }
    }
}
```



## 哈希表

### 840.模拟哈希表

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=2000003,null=0x3f3f3f3f;//开放寻址法，定N时，要扩大到数据范围的2~3倍
int a[N];
int find(int x)
{
    int k=(x%N+N)%N;
    while(a[k]!=x&&a[k]!=null) k++;//if(k==N) k=0;这题的数据用不上这个，但是其他题不一定。作用：防止数组越界
    return k;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    memset(a,0x3f,sizeof a);//int类型为四个字节，所以会有四个3f
    for(int i=0;i<n;i++)
    {
        char t;
        int x;
        scanf("%c %d\n",&t,&x);
        int s=find(x);
        if(t=='I') a[s]=x;
        else
        {
            if(a[s]==x) printf("Yes\n");
            else printf("No\n");
        }
    }
}
```

### 841.字符串哈希

M一般为131/13331

```c
#include<iostream>
using namespace std;
typedef unsigned long long ULL;
const int N=100010,M=131;
ULL a[N],p[N];//a数组是将字符串转为一个M进制的数，p数组代表M^i的值
int main()
{
    int n,m;
    scanf("%d %d\n",&n,&m);
    p[0]=1;//M^0=1
    char c;
    for(int i=1;i<=n;i++) 
    {
        scanf("%c",&c);
        a[i]=a[i-1]*M+c;
        p[i]=p[i-1]*M;
    }
    int x1,y1,x2,y2;
    for(int i=0;i<m;i++)
    {
        scanf("%d %d %d %d\n",&x1,&y1,&x2,&y2);
        if((a[y1]-a[x1-1]*p[y1-x1+1])==(a[y2]-a[x2-1]*p[y2-x2+1])) printf("Yes\n");//意义：对齐
        else printf("No\n");
    }
}
```



# 第三讲：搜索与图论

## DFS

### 842.排列数字

```c
#include<iostream>
using namespace std;
int n;
int a[10]={0};
void dfs(int s,int x)
{
    if(s==n) 
    {
        for(int i=0;i<n;i++) printf("%d ",a[i]);
        printf("\n");
        return;
    }
    for(int i=0;i<n;i++)
    {
        if(!(x>>i&1))//有哪一位数还没有使用
        {
            a[s]=i+1;//如果x>>1&1==0说明可以选择i(二进制)，也就是选择i+1(十进制)
            dfs(s+1,x+(1<<i));//将这个位置变为1，如果当前x=3，i=0，x+(1<<i)=5，相当于二进制100的第0位变成了1，这样接下去就只能选着2(i=1)了
        }
    }
}
int main()
{
    scanf("%d\n",&n);
    dfs(0,0);
}
```

### 843.n-皇后问题

```c
#include<iostream>
using namespace std;
const int N=10;
int n=0;
char a[N][N];
bool row[N],col[N],dg[N*2],udg[N*2];//行，列，反斜线，斜线
void dfs(int x,int y,int s)
{
    if(s>n) return;
    if(y==n) y=0,x++;//换行
    if(x==n)
    {
        if(s==n)
        {
            for(int i=0;i<n;i++) puts(a[i]);
            puts("");
        }
        return;
    }
    a[x][y]='.';
    dfs(x,y+1,s);
    if(!row[x]&&!col[y]&&!dg[x+y]&&!udg[x-y+n])
    {
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=true;
        a[x][y]='Q';
        dfs(x,y+1,s+1);
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=false;
        a[x][y]='.';
    }
}
int main()
{
    scanf("%d\n",&n);
    dfs(0,0,0);
}
```

## BFS

### 844.走迷宫

```c
#include<iostream>
#include<queue>
using namespace std;
typedef pair<int,int> PLL;
const int N=110;
int n,m;
int a[N][N],d[N][N];
bool st[N][N];
int sum;
void bfs()
{
    int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
    queue<PLL> q;
    q.push({0,0});
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int x=t.first+dx[i],y=t.second+dy[i];
            if(x>=0&&x<n&&y>=0&&y<m&&a[x][y]==0&&!st[x][y])
            {
                st[x][y]=true;
                d[x][y]=d[t.first][t.second]+1;
                q.push({x,y});
            }
        }
    }
    
}
int main()
{
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++) scanf("%d",&a[i][j]);
    bfs();
    printf("%d\n",d[n-1][m-1]);
}
```

### 845.八数码

```c
#include<iostream>
#include<algorithm>
#include<queue>
#include<map>
using namespace std;
const int N=10;
string a,b;
int bfs()
{
    int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
    map<string,int> hash;
    queue<string> q;
    q.push(b);
    hash[b]=0;
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        if(t==a) return hash[t];
        int d=hash[t];
        int k=t.find('x');
        int x=k/3,y=k%3;
        for(int i=0;i<4;i++)
        {
            int x1=x+dx[i],y1=y+dy[i];
            if(x1>=0&&x1<3&&y1>=0&&y1<3)
            {
                swap(t[x1*3+y1],t[k]);
                if(!hash.count(t))
                {
                    hash[t]=d+1;
                    q.push(t);
                }
                swap(t[x1*3+y1],t[k]);
            }
        }
    }
    return -1;
}
int main()
{
    char t;
    for(int i=0;i<9;i++) 
    {
        scanf("%c ",&t);
        b+=t;
    }
    a="12345678x";
    printf("%d\n",bfs());
}
```

## 树与图的深度优先遍历

### 846.树的重心

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=100010,M=N*2;
int h[N],ne[M],e[M],sum;
bool st[N];
int n;
int res=N;
void add(int x,int y)//建图
{
    ne[sum]=h[x],e[sum]=y,h[x]=sum++;
}
int dfs(int x)
{
    st[x]=true;
    int s=0,size=0;//size：删除该节点时的连通块的点数的最大值
    for(int i=h[x];i!=-1;i=ne[i])
    {
        int t=e[i];
        if(st[t]) continue; 
        int m=dfs(t);//它的下层节点的分支中的连通块中的点数
        size=max(size,m);//它的下层节点的分支中的连通块中的点数的最大值
        s+=m;
    }
    size=max(size,n-s-1);//n-s-1：它的上层节点的连通块中的点数
    res=min(size,res);//删除该节点时的连通块的点数的最大值中的最小值
    return s+1;//以该节点为根节点的树的节点数
}
int main()
{
    scanf("%d\n",&n);
    memset(h,-1,sizeof h);
    for(int i=0;i<n;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
        add(y,x);
    }
    dfs(1);
    printf("%d\n",res);
}
```

##  树与图的广度优先搜索

### 847.图中点的层数

```c
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=100010;
int h[N],ne[N],e[N],res;
int n,m;
int d[N];
bool st[N];
void add(int x,int y)
{
    e[res]=y,ne[res]=h[x],h[x]=res++;
}
int bfs()
{
    queue<int> q;
    q.push(1);
    st[1]=true;
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        if(t==n) return d[n];
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int s=e[i];
            if(!st[s])
            {
                st[s]=true;
                d[s]=d[t]+1;
                q.push(s);
            }
        }
    }
    return -1;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    while(m--)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
    }
    printf("%d\n",bfs());
}
```



## 拓扑排序

### 848.有向图的拓扑序列

#### 条件：有向无环图

```c
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100010;
int h[N],e[N],ne[N];
int s=0;W[[S
int a[N];
int d[N];
int n,m;
queue<int> q;
int add(int x,int y)//建图
{
    ne[s]=h[x],e[s]=y,h[x]=s++;
}
bool topsort()
{
    int sz=0;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        a[sz++]=t;
        for(int j=h[t];j!=-1;j=ne[j])
        {
            d[e[j]]--;//入度减1
            if(d[e[j]]==0) q.push(e[j]);//入度为0，进入排序
        }
    }
    if(sz==n) return true;
    else return false;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
        d[y]++;
    }
    for(int i=1;i<=n;i++)//入度为0的点
    {
        if(d[i]==0) q.push(i);
    }
    if(topsort())
    {
        for(int i=0;i<n;i++) printf("%d ",a[i]);
    }
    else printf("-1\n");
}
```

## Dijkstra

边权一定不能为负数

### 849.Dijkstra求最短路径I

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=510;
int n,m;
int a[N][N],d[N];
bool st[N];
int dijkstra()
{
    memset(d,0x3f,sizeof d);
    d[1]=0;
    for(int i=0;i<n-1;i++)
    {
        int s=-1;
        for(int j=1;j<=n;j++)
        {
            if(!st[j]&&(s==-1||d[s]>d[j])) s=j;//找到没选择过的最短距离点
        }
        for(int j=1;j<=n;j++)
            d[j]=min(d[j],d[s]+a[s][j]);//更新最短路径
        st[s]=true;
    }
    if(d[n]==0x3f3f3f3f) return -1;
    else return d[n];
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(a,0x3f,sizeof a);
    while(m--)
    {
        int x,y,c;
        scanf("%d %d %d\n",&x,&y,&c);
        a[x][y]=min(a[x][y],c);//有重边
    }
    printf("%d\n",dijkstra());
}
```

### 850.Dijkstra求最短路II

```c
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int N=150010;
typedef pair<int,int> PII;
int n,m;
int h[N],ne[N],e[N],w[N],res;
int d[N];
bool st[N];
void add(int x,int y,int c)
{
    w[res]=c,e[res]=y,ne[res]=h[x],h[x]=res++;
}
int dijkstra()
{
    memset(d,0x3f,sizeof d);
    d[1]=0;
    priority_queue<PII,vector<PII>,greater<PII>> q;//小根堆
    q.push({0,1});//路径，节点，把路径放前面是为了让小根堆的排序按路径的长度来排
    while(q.size())
    {
        auto t=q.top();
        q.pop();
        int x=t.second;//找到最短距离点
        if(st[x]) continue;
        st[x]=true;
        for(int i=h[x];i!=-1;i=ne[i])
        {
            int y=e[i];
            if(d[y]>d[x]+w[i])//更新最短路径
            {
                d[y]=d[x]+w[i];
                q.push({d[y],y});
            }
        }
    }
    if(d[n]==0x3f3f3f3f) return -1;
    else return d[n];
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    while(m--)
    {
        int x,y,c;
        scanf("%d %d %d\n",&x,&y,&c);
        add(x,y,c);
    }
    printf("%d\n",dijkstra());
}
```

## bellman_ford

### 853.有边数限制的最短路径

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=510,M=100010;
int n,m,k;
struct Node
{
    int x,y,z;
};
Node a[M];
int d[N];
void bellman_ford()
{
    memset(d,0x3f,sizeof d);
    d[1]=0;
    for(int i=0;i<k;i++)//第i次代表了d中有不少于i+1条边的最短路径，第n次更新了的话有代表存在一条包含n条边的最短路径，所以一定包含n+1个点，一定有两个点的编号相同，必然存在负环
    {
        int t[N];
        memcpy(t,d,sizeof d);//副本，防止串联
        for(int i=0;i<m;i++) d[a[i].y]=min(d[a[i].y],t[a[i].x]+a[i].z);//更新最短路径
    }
}
int main()
{
    scanf("%d %d %d\n",&n,&m,&k);
    for(int i=0;i<m;i++) scanf("%d %d %d\n",&a[i].x,&a[i].y,&a[i].z);
    bellman_ford();
    if(d[n]>0x3f3f3f3f/2) printf("impossible\n");//存在边权值为负数的情况，会使d[n]不等于0x3f3f3f3f，但因为题目设定，也不会减太多
    else printf("%d\n",d[n]);
}
```

## spfa

对bellman_ford中遍历每一条路径这件事进行优化，若用spfa求最短路径，必须满足条件：不存在负权回路，但可以用spfa求该图是否存在负权回路

### 851.spfa求最短路径

```c
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=100010;
int n,m;
int h[N],ne[N],e[N],w[N],res;
int d[N];
bool st[N];
int add(int x,int y,int z)
{
    ne[res]=h[x],e[res]=y,w[res]=z,h[x]=res++;
}
void sofa()
{
    memset(d,0x3f,sizeof d);
    d[1]=0;
    queue<int> q;
    q.push(1);
    st[1]=true;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=false;//这次使用完，若该点的路径还会被更新，就还需要再次使用该点
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(d[j]>d[t]+w[i])
            {
                d[j]=d[t]+w[i];//更新路径
                if(!st[j])//若该点会被使用，无需再次添加，否者加入队列
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    while(m--)
    {
        int x,y,z;
        scanf("%d %d %d\n",&x,&y,&z);
        add(x,y,z);
    }
    sofa();
    if(d[n]==0x3f3f3f3f) printf("impossible\n");//这里可以等于是因为，这题不像上一题每一个点遍历，不会出现不是从1走到n的情况
    else printf("%d\n",d[n]);
}
```

### 852.spfa判断负环

```c
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=2010,M=10010;
int n,m;
int h[N],e[M],ne[M],w[M],res;
int d[N],cnt[N];//cnt：包含了多少条边
bool st[N];
void add(int x,int y,int z)
{
    e[res]=y,ne[res]=h[x],w[res]=z,h[x]=res++;
}
bool spfa()
{
    queue<int> q;
    for(int i=1;i<=n;i++)//是判断图中存不存在负环，不是从1到某条路径上是否存在负环，所以每个点都需要查找
    {
        q.push(i);
        st[i]=true;
    }
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=false;
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(d[j]>d[t]+w[i])//通过这个求法的得到的环一定是负环的原因是因为这个
            {
                d[j]=d[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;//边数大于n，说明一定有n+1个点，一定有两个点的编号相同，yi
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    while(m--)
    {
        int x,y,z;
        scanf("%d %d %d\n",&x,&y,&z);
        add(x,y,z);
    }
    if(spfa()) puts("Yes");
    else puts("No");
}
```

## Floyd

可以求每个点到每个点的最短路径，核心思想：动态规划

### 854.Floyd求最短路

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=210,INF=1e9;
int n,m,t;
int d[N][N];//每个点到每个点的最短路径
void floyd()
{
    for(int k=1;k<=n;k++)//中途经过的点
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//相当于d[k-1][i][k]+d[k-1][k][j];
}
int main()
{
    scanf("%d %d %d\n",&n,&m,&t);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i==j) d[i][j]=0;
            else d[i][j]=INF;
    for(int i=0;i<m;i++)
    {
        int x,y,z;
        scanf("%d %d %d\n",&x,&y,&z);
        d[x][y]=min(d[x][y],z);
    }
    floyd();
    for(int i=0;i<t;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        int q=d[x][y];
        if(q>INF/2) puts("impossible");
        else printf("%d\n",d[x][y]);
    }
}
```

## Prim

与Dijkstra算法类似，不同点在于Prim是用t更新其他点到集合的距离，而Dijkstra是用t更新其他点到该点的距离

这个有点像贪心思想，选最短的路径进行

### 858.Prim算法求最小生成树

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=510;
int n,m;
int a[N][N];
int d[N];
bool st[N];
int res;
bool prim()
{
    memset(d,0x3f,sizeof d);
    for(int i=0;i<n;i++)
    {
        int t=-1;
        for(int j=1;j<=n;j++)
            if(!st[j]&&(t==-1||d[t]>d[j])) t=j;
        if(i&&d[t]==0x3f3f3f3f) return false;//i!=0的情况下
        if(i) res+=d[t];
        st[t]=true;
        for(int j=1;j<=n;j++) d[j]=min(d[j],a[t][j]);//这里与Dijkstra不同的地方在于，求的是到集合的最短路径，并不是到1的最短路径
    }
    return true;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(a,0x3f,sizeof a);
    while(m--)
    {
        int x,y,z;
        scanf("%d %d %d\n",&x,&y,&z);
        a[x][y]=a[y][x]=min(a[x][y],z);
    }
    if(prim()) printf("%d\n",res);
    else puts("impossible");
}
```

## Kruskal

也是贪心思想，但与Prim有一点区别，并且用到了并查集，快排

### 859.Kruskal算法求最小生成树

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010,INF=0x3f3f3f3f;
struct Node
{
    int x,y,z;
};
bool cmp(Node i,Node j)
{
    return i.z<j.z;
}
int n,m;
Node a[N*2];
int d[N];
int find(int x)//并查集
{
    if(d[x]!=x) d[x]=find(d[x]);
    return d[x];
}
int kruskal()
{
    sort(a,a+m,cmp);
    for(int i=1;i<=n;i++) d[i]=i;
    int s=0,cnt=0;//路径，经过节点数
    for(int i=0;i<m;i++)
    {
        int x=a[i].x,y=a[i].y,z=a[i].z;
        x=find(x),y=find(y);
        if(x!=y)//不在同一个连通块(一棵树内)的情况下，将其并入集合中
        {
            d[x]=y;
            s+=z;//因为按边权值进行了排序，所以当前路径一定是最小值
            cnt++;
        }
    }
    if(cnt<n-1) return INF;
    return s;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<m;i++) scanf("%d %d %d\n",&a[i].x,&a[i].y,&a[i].z);
    int t=kruskal();
    if(t!=INF) printf("%d\n",t);
    else puts("impossible");
    
}
```

## 染色体判定二分图

### 860.染色体判定二分图

二分图性质：当且仅当图中不含有奇数环(有奇数条边围成的环)

```c
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100010,M=N*2;
int h[N],e[M],ne[M],res;
int n,m;
int d[N];
bool st[N];
void add(int x,int y)
{
    e[res]=y,ne[res]=h[x],h[x]=res++;
}
bool bfs(int s)
{
    queue<int> q;
    q.push(s);
    st[s]=true;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            if(d[t]==d[e[i]]&&st[e[i]]) return false;//使用过并且分组冲突的情况下，表示存在奇数环
            if(!st[e[i]])
            {
                q.push(e[i]);
                st[e[i]]=true;
                d[e[i]]=1-d[t];//分组
            }
        }
    }
    return true;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    memset(h,-1,sizeof h);
    int s=0;
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);
        add(y,x);
    }
    int flag=0;
    for(int i=1;i<=n;i++)
        if(!st[i]) 
            if(!bfs(i)) flag=1;
    if(flag==0) puts("Yes");
    else puts("No");
}
```

## 匈牙利算法

### 861.二分图的最大匹配

```c
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=510,M=100010;
int h[N],ne[M*2],e[M*2],res;
int n1,n2,m;
int r[N];
bool st[N];
void add(int x,int y)
{
    e[res]=y,ne[res]=h[x],h[x]=res++;
}
bool find(int x)
{
    for(int i=h[x];i!=-1;i=ne[i])
    {
        int t=e[i];
        if(!st[t])
        {
            st[t]=true;
            if(r[t]==0||find(r[t]))//r没有匹配对象或者匹配对象可以换时，当前x可以找到匹配对象
            {
                r[t]=x;//r的匹配对象
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d %d %d\n",&n1,&n2,&m);
    memset(h,-1,sizeof h);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        add(x,y);//虽然这题是无向图，但是只用连接一边的就可以了，另一边用来实现1对1
    }
    int s=0;
    for(int i=1;i<=n1;i++)
    {
        memset(st,false,sizeof st);
        if(find(i)) s++;//当前i可以找到匹配对象的话，说明又连接了一条边
    }
    printf("%d\n",s);
}
```

# 第四讲：数学知识

## 质数

### 866.试除法判定质数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int x=0;
        scanf("%d\n",&x);
        int flag=0;
        for(int j=2;j<=x/j;j++)//重点在这
        {
            if(x%j==0) 
            {
                flag=1;
                break;
            }
        }
        if(flag||x==1) puts("No");//1为特殊情况
        else puts("Yes");
    }
}
```

### 867.分解质因数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        int x=0;
        scanf("%d\n",&x);
        for(int j=2;j<=x/j;j++)
        {
            if(x%j==0)
            {
                int res=0;
                while(x%j==0) 
                {
                    x/=j;
                    res++;
                }
                printf("%d %d\n",j,res);
            }
        }
        if(x>1) printf("%d %d\n",x,1);
        puts("");
    }
}
```

### 868.筛质数

```c
#include<iostream>
using namespace std;
bool st[1000010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int res=0;
    for(int i=2;i<=n;i++)
    {
        if(st[i]) continue;//不是质数pai
        st[i]=true;
        res++;
        for(int j=i+i;j<=n;j+=i) st[j]=true;//i的倍数排除
    }
    printf("%d\n",res);
}
```

## 约数

### 869.试除法求约数

```c
#include<iostream>
#include<algorithm>
using namespace std;
int a[1000010];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    while(n--)
    {
        int x=0;
        scanf("%d\n",&x);
        int sz=0;
        for(int i=1;i<=x/i;i++)
        {
            if(x%i==0) 
            {
                a[sz++]=i;
                if(x/i!=i) a[sz++]=x/i;
            }
        }
        sort(a,a+sz);
        for(int i=0;i<sz;i++) printf("%d ",a[i]);
        printf("\n");
    }
}
```

### 870.约数个数

前置知识：算术基本定理：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积
$$
N=P1^a¹·P2^a²·P3^a³·……·Pn^aⁿ
$$
这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数。

int范围内拥有最多的约数个数的大约有1500个左右
$$
约数个数：(a1+1)*(a2+1)*(a3+1)*(a4+1)*……*(an+1)
$$

$$
约数之和：(p1^0+p1^1+……+p1^n)*……*(pk^0+pk^1+……+pk^n)
$$

```c
#include<iostream>
#include<map>
using namespace std;
int mod=1e9+7;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    map<int,int> m;
    while(n--)
    {
        int x=0;
        scanf("%d\n",&x);
        for(int j=2;j<=x/j;j++)
        {
            while(x%j==0) 
            {
                x/=j;
                m[j]++;
            }
        }
        if(x>1) m[x]++;
    }
    long long res=1;
    for(auto t:m) res=res*(t.second+1)%mod;
    printf("%lld\n",res);
}
```

### 871.约数之和

```c
#include<iostream>
#include<map>
using namespace std;
int mod=1e9+7;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    map<int,int> m;
    while(n--)
    {
        int x=0;
        scanf("%d\n",&x);
        for(int i=2;i<=x/i;i++)
        {
            while(x%i==0)
            {
                x/=i;
                m[i]++;
            }
        }
        if(x>1) m[x]++;
    }
    long long res=1;
    for(auto t:m)
    {
        long long s=1;
        long long cnt=t.first;
        for(int i=1;i<=t.second;i++)
        {
            s=(s+cnt)%mod;;
            cnt=cnt*t.first%mod;
        }
        res=res*s%mod;
    }
    printf("%lld\n",res);
}
```

### 872.最大公约数

```c
#include<iostream>
#include<algorithm>
using namespace std;
int gcd(int x,int y)
{
    return y?gcd(y,x%y):x;//y为真，运行gcd(y,x%y)，为假，运行x
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    while(n--)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        printf("%d\n",gcd(x,y));
    }
}
```

## 欧拉函数

[容斥原理](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/#%E5%AE%B9%E6%96%A5%E6%A8%A1%E5%9E%8B_1)

### 873.欧拉函数

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    while(n--)
    {
        int x=0;
        scanf("%d\n",&x);
        int res=x;
        for(int i=2;i<=x/i;i++)
        {
            if(x%i==0)
            {
                while(x%i==0) x/=i;
                res=res/i*(i-1);//因为不能有小数运算，所以要写成这样
            }
        }
        if(x>1) res=res/x*(x-1);
        printf("%d\n",res);
    }
}
```

### 874.筛法求欧拉函数

```c
#include<iostream>
using namespace std;
const int N=1000010;
int a[N];
long long d[N];
bool st[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int sz=0;
    long long res=0;
    d[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!st[i])//当前i为素数时
        {
            a[sz++]=i;
            d[i]=i-1;
        }
        for(int j=0;a[j]<=n/i&&j<sz;j++)
        {
            int t=a[j]*i;//组合
            st[t]=true;
            if(i%a[j]==0)//说明d[i]中是乘了a[j]的分数了的
            {
                d[t]=d[i]*a[j];//这里再乘a[j]是因为N的值扩大了a[j]倍
                break;
            }
            d[t]=d[i]*(a[j]-1);//d[i]中没有乘了a[j]的分数，这不用除a[j]是因为t扩大了a[j]倍，抵消了
        }
    }
    for(int j=1;j<=n;j++) res+=d[j];
    printf("%lld\n",res);
}
```

## 快速幂

### 875.快速幂

$$
a^9=a^(2^3+2^0)=a^(2^3)*a^(2^0)
$$



```c
#include<iostream>
using namespace std;
long long qmi(int a,int b,int mod)
{
    long long res=1;
    while(b)
    {
        if(b&1) res=res*a%mod;//二进制最后一位为1时
        a=(long long)a*a%mod;
        b>>=1;//除二
    }
    return res;
}
int main()
{
    int n=0;
    scanf("%d\n",&n);
    while(n--)
    {
        int a,b,mod;
        scanf("%d %d %d\n",&a,&b,&mod);
        printf("%lld\n",qmi(a,b,mod));
    }
}
```

## 求组合数

### 885.求组合数 l

$$
组合性质：C(n,m)=C(n-1,m)+C(n-1,m-1)
$$

```c
#include<iostream>
using namespace std;
const int N=2010,mod=1e9+7;
int a[N][N];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<=2000;i++) a[i][0]=1;
    for(int i=1;i<=2000;i++)
        for(int j=1;j<=i;j++)
            a[i][j]=(a[i-1][j]+a[i-1][j-1])%mod;
    for(int i=0;i<n;i++)
    {
        int x,y;
        scanf("%d %d\n",&x,&y);
        printf("%d\n",a[x][y]);
    }
}
```

## 博弈论

### 891.Nim游戏

必胜态：异或和不为零

必败态：异或和为零

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int res=0;
    for(int i=0;i<n;i++) 
    {
        int a;
        scanf("%d\n",&a);
        res^=a;
    }
    
    if(res) puts("Yes");
    else puts("No");
}
```

### 892.台阶-Nim游戏

```c
#include<iostream>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    int res=0;
    for(int i=0;i<n;i++)
    {
        int a=0;
        scanf("%d ",&a);
        if(!(i&1)) res^=a;
    }
    if(res) puts("Yes");
    else puts("No");
}
```



# 第六讲

## 区间问题

### 905.区间选点

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
struct node
{
    int x,y;
};
bool cmp(node i,node j)//以y的值从小到大排序
{
    if(i.y==j.y) return i.x<j.x;
    return i.y<j.y;
}
node a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d %d\n",&a[i].x,&a[i].y);
    sort(a,a+n,cmp);
    int res=1;
    int t=a[0].y;
    for(int i=0;i<n;i++)
    {
        if(a[i].x>t)//当前选点为时t，如果i的x值小于等于t的情况下，a[i]区间一定包括t点，a[i].y一定大于等于t
        {
            t=a[i].y;
            res++;
        }
    }
    printf("%d\n",res);
}
```

### 908.最大不相交区间数量

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
struct node
{
    int x,y;
};
bool cmp(node i,node j)
{
    if(i.y==j.y) return i.x<j.x;
    return i.y<j.y;
}
node a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d %d\n",&a[i].x,&a[i].y);
    sort(a,a+n,cmp);
    int res=1;
    int t=a[0].y;
    for(int i=0;i<n;i++)
    {
        if(a[i].x>t) 
        {
            res++;
            t=a[i].y;
        }
    }
    printf("%d\n",res);
}
```

### 906.区间分组

```c
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int N=100010;
struct node
{
    int x,y;
};
bool cmp(node i,node j)
{
    if(i.x==j.x) return i.y<j.y;
    return i.x<j.x;
}
node a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d %d\n",&a[i].x,&a[i].y);
    sort(a,a+n,cmp);
    priority_queue<int ,vector<int>,greater<int>> heap;
    for(int i=0;i<n;i++)
    {
        if(heap.empty()||heap.top()>=a[i].x) heap.push(a[i].y);//若当前heap为空，添加组，或者当最小的最远端都包含了该节点的值，说明分的所有组都与该区间有交集，添加组
        else//最小的最远端没有包含该区间的点，将该区间加到这组中
        {
            heap.pop();//删除该组
            heap.push(a[i].y);//将更新后的该组重新加回堆中
        }
    }
    printf("%d\n",heap.size());
}
```

### 907.区间覆盖

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
struct node
{
    int x,y;
};
bool cmp(node i,node j)
{
    if(i.x==j.x) return i.y<j.y;
    return i.x<j.x;
}
node a[N];
int main()
{
    int l,r;
    scanf("%d %d\n",&l,&r);
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d %d\n",&a[i].x,&a[i].y);
    sort(a,a+n,cmp);
    int res=0;
    int flag=0;
    for(int i=0;i<n;i++)
    {
        int j=i,t=-2e9;
        while(j<n&&a[j].x<=l)//找到包括该节点的区间
        {
            t=max(t,a[j].y);//在这些区间中找到最远的点，选择这个区间
            j++;
        }
        if(t<l)//如果在这些区间中的最大值都小于当前节点，说明无法覆盖区间
        {
            res=-1;
            break;
        }
        res++;//当前有最远端大于l的点，选择该区间
        if(t>=r)//当前选择的最远端大于r，说明已覆盖区间，结束
        {
            flag=1;
            break;
        }
        l=t;//更新当前已覆盖的最远端点
        i=j-1;
    }
    if(flag==0) printf("-1\n");
    else printf("%d\n",res);
}
```



## Huffman树

### 148.合并果子

贪心策略：每次都选择最小的两堆果子进行合并

```c
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
int main()
{
    int n=0;
    scanf("%d\n",&n);
    priority_queue<int,vector<int>,greater<int>> heap;
    for(int i=0;i<n;i++)
    {
        int s=0;
        scanf("%d\n",&s);
        heap.push(s);
    }
    int res=0;//消耗的体力
    for(int i=0;i<n-1;i++)
    {
        int b=heap.top();
        heap.pop();
        int a=heap.top();
        heap.pop();
        res+=a+b;
        heap.push(a+b);//两合并为一堆和，还是要加入回待合并堆的
    }
    printf("%d\n",res);
}
```

## 排序不等式

### 913.排队打水

贪心策略：从小到大排序，这样需要等待的打水时间长的时间人就会少

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d ",&a[i]);
    sort(a,a+n);
    long long res=0,s=a[0];
    for(int i=1;i<n;i++)
    {
        res+=s;
        s+=a[i];
    }
    printf("%lld\n",res);
}
```

## 绝对值不等式

### 104.仓库选址

贪心策略：中位数到各点的距离和最短

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
int a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++) scanf("%d\n",&a[i]);
    sort(a,a+n);
    int k=a[n/2];//zhon
    if(!n&1) k=(a[n/2]+a[n/2+1])/2;
    int res=0;
    for(int i=0;i<n;i++) res+=abs(a[i]-k);
    printf("%d\n",res);
}
```

## 推公式

### 125.耍杂技的牛

贪心策略：按重量+强度的来排序

原理：

|        | i的风险值                   | i+1的风险值            |
| :----- | --------------------------- | ---------------------- |
| 交换前 | W1+W2+……+Wi-1  -  Si        | W1+W2+……+Wi  -  Si+1   |
| 交换后 | W1+W2+……+Wi-1+Wi+1  -  Si+1 | W1+W2+……+Wi-1  -  Si+1 |

就等于

|        | i的风险值   | i+1的风险值 |
| :----- | ----------- | ----------- |
| 交换前 | -  Si       | Wi  -  Si+1 |
| 交换后 | Wi+1  -  Si | -  Si+1     |

若：Wi+Si>Wi+1+Si+1,则说明交换后风险值一定比交换后的风险值小，所以以重量+强度的来排序得到的风险值的最大值最小

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=50010;
struct node
{
    int x,y;
};
bool cmp(node i,node j)
{
    if(i.x==j.x) return i.y<j.y;
    return i.x<j.x;
}
node a[N];
int main()
{
    int n=0;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d %d\n",&a[i].x,&a[i].y);
        a[i].x+=a[i].y;
    }
    sort(a,a+n,cmp);
    long long res=0;
    long long m=-2e9;
    for(int i=0;i<n;i++)//第一只牛也是有风险值的
    {
        m=max(m,res-a[i].y);
        res+=a[i].x-a[i].y;
    }
    printf("%lld\n",m);
}
```

