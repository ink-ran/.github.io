---
title: 周赛补题
date: 2023-03-27 23:25:18
tags:
---

# T1

## 2603.收集树中金币

1.先用拓扑排序将没有意义的叶子摘掉(去除不包含金币的子树)。叶子：最底下的节点(没有出度的节点)。没有意义：该叶子没有金币。

2.只考虑有金币的叶子，不在叶子上的金币在行走时一定可以收集到。

3.从有金币的叶子出发在次进行拓扑排序，并且在此次排序中，记录每个点入队的时间。**(入队非访问)**

4.如果满足time[x]≥2且time[y]≥2(两个相通的节点的入队时间都大于二，说明要从x走向y)，那么这条边需要恰好经过 2 次（因为需要回到出发点），答案加 2；如果不满足，则无需经过。

```c
class Solution {
    int n;
    vector<vector<int>> a;//图
    int d[30010];//边的数量
    int time[30010];//入队时间
    void subtopsort(vector<int> coins)
    {
        queue<int> q;
        for(int i=0;i<n;i++)
        {
            if(d[i]==1&&coins[i]==0) q.push(i);//将无金币子树减掉
        }
        while(q.size())
        {
            int t=q.front();
            q.pop();
            for(int i=0;i<a[t].size();i++)
            {
                d[a[t][i]]--;
                if(d[a[t][i]]==1&&coins[a[t][i]]==0) q.push(a[t][i]);//将a[t][i]叶子剪掉后，与a[t][i]连通有某些节点变为叶子并且也是无意义的叶子时，添加进删除行列。
            }
        }
    }
    bool topsort(vector<int> coins)
    {
        queue<int> q;
        for(int i=0;i<n;i++)
        {
            if(d[i]==1&&coins[i]==1) q.push(i);//为叶子的有金币节点
        }
        if(q.size()<=1) return false;//最多有一个金币的叶子直接收集
        while(q.size())
        {
            int t=q.front();
            q.pop();
            for(int i=0;i<a[t].size();i++)
            {
                d[a[t][i]]--;
                if(d[a[t][i]]==1)
                {
                    q.push(a[t][i]);//将a[t][i]叶子剪掉后，与a[t][i]连通有某些节点变为叶子,入队。
                    time[a[t][i]]+=time[t]+1;//入队时间
                }
            }
        }
        return true;
    }
public:
    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
        n=coins.size();
        a.resize(n);
        for(int i=0;i<edges.size();i++)//建图
        {
            a[edges[i][0]].push_back(edges[i][1]);
            a[edges[i][1]].push_back(edges[i][0]);
            d[edges[i][0]]++;
            d[edges[i][1]]++;
        }
        subtopsort(coins);
        if(topsort(coins)==false) return 0;
        else
        {
            int sum=0;
            for (int i=0;i<edges.size();i++)
            if (time[edges[i][0]] >= 2 && time[edges[i][1]] >= 2) sum += 2;//入队时间都大于2，说明一定要走到这两个点，，而题目要求要走回出发点，所以这条路会走两遍。
            return sum;
        }
    }
};
```



# T2

# 第96场周赛

## 4878.维护数组

树状数组

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int N=200010;
int n,k,a,b,q;
int d[N];
int l[N],r[N];//我觉得有点像前缀的的样子，但是存储方式？？
int lowbit(int x)
{
    return x & -x;//返回二进制的最低位，3:11 -> 01:1   6:110 -> 010:2
}
void add(int tr[],int x,int v)
{
    for(int i=x;i<=n;i+=lowbit(i))//为什么要这样子添加？
    {
        tr[i]+=v;
    }
}
int query(int tr[],int x)
{
    int sum=0;
    for(int i=x;i;i-=lowbit(i))//查找，应该是因为添加方式所以才这样查找
    {
        sum+=tr[i];
    }
    return sum;
}
int main()
{
    cin>>n>>k>>a>>b>>q;
    for(int i=0;i<q;i++)
    {
        int t=0;
        cin>>t;
        if(t==1)
        {
            int x,y;
            cin>>x>>y;
            add(l,x,min(d[x]+y,b)-min(d[x],b));
            add(r,x,min(d[x]+y,a)-min(d[x],a));
            d[x]+=y;
        }
        if(t==2)
        {
            int p;
            cin>>p;
            printf("%d\n",query(l,p-1)+query(r,n)-query(r,p+k-1));//前缀和求值得样子
        }
    }
}
```



# T3
